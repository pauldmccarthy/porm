#!/bin/python
#
# porm - simple sqlite3 <-> python ORM layer
#
# This file provides very simple logic for conversion between rows of 
# a database table and lists of python objects. It supports lookup of
# simple types, and of basic one-to-many foreign key references.
#
# The following assumptions are made:
#
#   - All tables contain an 'id' field.
#   - Said id field is automatically generated by the database upon 
#     insertion.
#   - All valid id values are > 0.
#   - Foreign key fields reference the id field of the referenced table, 
#     and are named according to the following convention:
#
#       [table]_id
# 
#     where [table] is the name of the referenced table.
#   - Circular foreign key relationships do not exist.
#   - No table contains foreign key references to itself.
#
# Typical initialisation would be as follows:
#
#   # create db and ORM layer
#   db = sqlite3.Connection('my.db')
#   orm = Porm.porm(db)
#
#   # add your db table <-> python object mappings
#   orm.addMapping('Person',  mymodel.Person)
#   orm.addMapping('Address', mymodel.Address)
#
# Note: this module has no dependency upon sqlite3; it merely requires
#       objects which look and behave like the sqlite3.Connection and 
#       sqlite3.Cursor objects.
#
# Author: Paul McCarthy <pauld.mccarthy@gmail.com>
#

class Pormo:
  """
Base ORM object; used if the user does not provide a desired class type.
  """
  pass

class Porm:
  """
ORM management object; create one of these to do stuff.
  """

  def __init__(self, db):
    """
Saves a handle to the given sqlite3 Connection object.

db - handle to a sqlite3 Connection object
    """
    self.db     = db
    self.ormmap = {}

  def addMapping(self, table, clazz):
    """
Adds a mapping between the given table and class. Subsequent queries on 
the given table will return instances of the given class.
    """
    self.ormmap[table] = clazz

  def query(self, table, where='', fkeylookup=True):
    """
Queries the given table according to the given where clause. Returns a 
list of objects representing the rows returned from the query.

table      - the name of the table to query
where      - the optional sql where clause
fkeylookup - optional, defaults to True; if false, foreign key lookups are
             not executed

As an example, to execute the given query:
  select * from people where age > 27

you would do this:
  oldies = porm.query(db, 'people', 'age > 27')
    """

    if len(where) is not 0: where = 'where %s' % where

    query = 'select * from %s %s' % (table, where)

    cursor = self.db.execute(query)
    return self.orm(table, cursor, fkeylookup)

  def save(self, table, instance):
    """
Saves the given instance to the given table. If the instance already exists
it is updated; otherwise it is inserted.

table    - name of the table to save the instance to
instance - the instance to save
    """

    # no id - assume this is a new instance
    exists = True
    try: 
      getattr(instance, 'id')
      if instance.id <= 0: exists = False

    except: exists = False

    # id has been given - check to see if it is valid
    if exists:

      query  = 'select * from %s where id = %i' % (table, instance.id)
      exists = self.db.execute(query).fetchall()
      exists = len(exists) is not 0

    fields = [f for f in dir(instance) if f[0:2] != '__' and f != 'id']
    values = [getattr(instance, f) for f in fields]

    # replace any foreign key objects with their ids
    for i in range(len(values)):
      if fields[i].endswith('_id') and type(values[i]) != type(1):
        values[i] = values[i].id

    # wrapping all values with single quotes may not 
    # work with a non sqlite3 database; i'm not sure
    values = map(str, values)
    values = ['\'%s\'' % v for v in values]

    # update existing instance
    if exists:

      exprs = ','.join(['%s=%s' % e for e in zip(fields, values)])
      stmt  = 'update %s set %s where id=%i' % (table, exprs, instance.id)
      self.db.execute(stmt)

    # insert new instance
    else:

      fields = '%s' % ','.join(fields)
      values = '%s' % ','.join(values)

      stmt = 'insert into %s (%s) values (%s)' % (table, fields, values)
      self.db.execute(stmt)

    self.db.commit()

  def orm(self, table, cursor, fkeylookup=True):
    """
Retrieves the rows from the given sqlite3 cursor and attempts to convert 
them into representative python objects. Any field which is a foreign key
to another table triggers a lookup; that field in the python object is set
to the subsequent python object returned from that lookup. A field is 
considered a foreign key if it is named as follows:

  [table]_id

The presence of a field named as such will trigger a lookup:
  select * from [table] where id = [field_value]

The subsequent field in the returned python objects will be set to the 
(first) result of this lookup for each row.

A table containing a reference to itself, or two (or more tables) with a 
circular foreign key relationship will cause infinite recursion.

table      - name of the table in question
cursor     - handle to a valid sqlite3 Cursor object
fkeylookup - optional, defaults to True; if false, foreign key lookups are 
             not executed
    """
    
    objs     = []
    rows     = cursor.fetchall()
    rownames = [d[0] for d in cursor.description]

    for row in rows:
  
      try:    clazz = self.ormmap[table]
      except: clazz = Pormo 

      obj = clazz()
  
      for i in range(len(rownames)):

        name = rownames[i]
        val  = row[i]
        
        # foreign key lookup
        if fkeylookup and len(name) > 3 and name[-3:] == '_id':

          val = self.query(name[:-3], 'id = %i' % val)

          if len(val) >= 1: setattr(obj, name, val[0])
          else:             setattr(obj, name, None)

        # simple type
        else:
          setattr(obj, name, val)

      objs.append(obj)

    return objs

